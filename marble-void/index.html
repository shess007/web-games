<!DOCTYPE html>

<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <title>VOID MARBLE</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@300;500&display=swap');

```
    * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        touch-action: none;
        -webkit-touch-callout: none;
        -webkit-user-select: none;
        user-select: none;
    }
    
    html, body {
        width: 100%;
        height: 100%;
        overflow: hidden;
        background: #000;
        font-family: 'Rajdhani', sans-serif;
    }
    
    #game-container {
        width: 100%;
        height: 100%;
        position: relative;
        background: #000;
    }
    
    #game-canvas {
        width: 100%;
        height: 100%;
        display: block;
    }
    
    /* Start Screen */
    #start-screen {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: radial-gradient(ellipse at center, #0a0a15 0%, #000 100%);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        z-index: 100;
        transition: opacity 0.8s ease, visibility 0.8s;
    }
    
    #start-screen.hidden {
        opacity: 0;
        visibility: hidden;
        pointer-events: none;
    }
    
    .title {
        font-family: 'Orbitron', monospace;
        font-size: clamp(2.5rem, 12vw, 4rem);
        font-weight: 900;
        letter-spacing: 0.3em;
        color: transparent;
        background: linear-gradient(135deg, #fff 0%, #6ee7ff 50%, #fff 100%);
        -webkit-background-clip: text;
        background-clip: text;
        text-shadow: 0 0 60px rgba(110, 231, 255, 0.5);
        margin-bottom: 1rem;
        animation: pulse-glow 3s ease-in-out infinite;
    }
    
    @keyframes pulse-glow {
        0%, 100% { filter: brightness(1); }
        50% { filter: brightness(1.3); }
    }
    
    .subtitle {
        font-size: clamp(0.8rem, 3vw, 1rem);
        color: rgba(110, 231, 255, 0.6);
        letter-spacing: 0.5em;
        text-transform: uppercase;
        margin-bottom: 3rem;
    }
    
    .marble-preview {
        width: 60px;
        height: 60px;
        border-radius: 50%;
        background: radial-gradient(circle at 30% 30%, #fff, #6ee7ff, #0ea5e9, #0369a1);
        box-shadow: 
            0 0 40px rgba(110, 231, 255, 0.8),
            0 0 80px rgba(110, 231, 255, 0.4),
            inset 0 0 20px rgba(255, 255, 255, 0.5);
        margin-bottom: 3rem;
        animation: float 3s ease-in-out infinite;
    }
    
    @keyframes float {
        0%, 100% { transform: translateY(0); }
        50% { transform: translateY(-15px); }
    }
    
    .start-btn {
        font-family: 'Orbitron', monospace;
        font-size: 1.2rem;
        font-weight: 700;
        padding: 1rem 3rem;
        background: transparent;
        border: 2px solid rgba(110, 231, 255, 0.5);
        color: #6ee7ff;
        letter-spacing: 0.3em;
        cursor: pointer;
        transition: all 0.3s ease;
        position: relative;
        overflow: hidden;
    }
    
    .start-btn::before {
        content: '';
        position: absolute;
        top: 0;
        left: -100%;
        width: 100%;
        height: 100%;
        background: linear-gradient(90deg, transparent, rgba(110, 231, 255, 0.2), transparent);
        transition: left 0.5s ease;
    }
    
    .start-btn:hover::before,
    .start-btn:active::before {
        left: 100%;
    }
    
    .start-btn:active {
        background: rgba(110, 231, 255, 0.1);
        transform: scale(0.98);
    }
    
    .instructions {
        position: absolute;
        bottom: 15%;
        text-align: center;
        color: rgba(255, 255, 255, 0.4);
        font-size: 0.85rem;
        line-height: 1.8;
        padding: 0 2rem;
    }
    
    .instructions span {
        color: rgba(110, 231, 255, 0.7);
    }
    
    /* HUD */
    #hud {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        padding: 1.5rem;
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        pointer-events: none;
        z-index: 50;
        opacity: 0;
        transition: opacity 0.5s ease;
    }
    
    #hud.visible {
        opacity: 1;
    }
    
    .hud-item {
        font-family: 'Orbitron', monospace;
        color: rgba(110, 231, 255, 0.8);
        text-shadow: 0 0 10px rgba(110, 231, 255, 0.5);
    }
    
    .level-display {
        font-size: 0.7rem;
        letter-spacing: 0.3em;
    }
    
    .level-num {
        font-size: 1.5rem;
        font-weight: 900;
    }
    
    .timer {
        font-size: 1.2rem;
        font-weight: 700;
        letter-spacing: 0.1em;
    }
    
    /* Win Screen */
    #win-screen {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: radial-gradient(ellipse at center, rgba(16, 185, 129, 0.1) 0%, rgba(0, 0, 0, 0.95) 100%);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        z-index: 100;
        opacity: 0;
        visibility: hidden;
        transition: opacity 0.5s ease, visibility 0.5s;
    }
    
    #win-screen.visible {
        opacity: 1;
        visibility: visible;
    }
    
    .win-title {
        font-family: 'Orbitron', monospace;
        font-size: clamp(1.5rem, 8vw, 2.5rem);
        font-weight: 900;
        color: #10b981;
        letter-spacing: 0.2em;
        text-shadow: 0 0 40px rgba(16, 185, 129, 0.8);
        margin-bottom: 1rem;
        animation: win-pulse 1s ease-in-out infinite;
    }
    
    @keyframes win-pulse {
        0%, 100% { transform: scale(1); }
        50% { transform: scale(1.05); }
    }
    
    .win-time {
        font-family: 'Orbitron', monospace;
        font-size: 1rem;
        color: rgba(16, 185, 129, 0.7);
        letter-spacing: 0.3em;
        margin-bottom: 2rem;
    }
    
    .next-btn {
        font-family: 'Orbitron', monospace;
        font-size: 1rem;
        font-weight: 700;
        padding: 1rem 2.5rem;
        background: transparent;
        border: 2px solid rgba(16, 185, 129, 0.5);
        color: #10b981;
        letter-spacing: 0.2em;
        cursor: pointer;
        pointer-events: auto;
        transition: all 0.3s ease;
    }
    
    .next-btn:active {
        background: rgba(16, 185, 129, 0.1);
        transform: scale(0.98);
    }
    
    /* Permission denied */
    #permission-error {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        text-align: center;
        color: #ff6b6b;
        font-size: 1rem;
        padding: 2rem;
        display: none;
        z-index: 200;
    }
    
    #permission-error.visible {
        display: block;
    }
    
    /* Reveal flash effect */
    .reveal-flash {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: radial-gradient(circle at var(--x, 50%) var(--y, 50%), rgba(110, 231, 255, 0.3) 0%, transparent 50%);
        pointer-events: none;
        opacity: 0;
        z-index: 40;
    }
    
    /* Wall collision indicator */
    #collision-indicator {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: 30;
        opacity: 0;
        transition: opacity 0.1s ease;
    }
    
    #collision-indicator.active {
        opacity: 1;
    }
</style>
```

</head>
<body>
    <div id="game-container">
        <canvas id="game-canvas"></canvas>

```
    <div id="hud">
        <div class="hud-item level-display">
            LEVEL<br>
            <span class="level-num" id="level-num">1</span>
        </div>
        <div class="hud-item timer" id="timer">00:00</div>
    </div>
    
    <div id="start-screen">
        <h1 class="title">VOID</h1>
        <p class="subtitle">Marble in the Dark</p>
        <div class="marble-preview"></div>
        <button class="start-btn" id="start-btn">BEGIN</button>
        <div class="instructions">
            <span>Tilt your phone</span> to guide the marble<br>
            Or <span>drag on screen</span> if no motion sensor<br>
            Find the <span>glowing target</span> in the darkness
        </div>
    </div>
    
    <div id="win-screen">
        <h2 class="win-title">VOID CLEARED</h2>
        <p class="win-time" id="win-time">TIME: 00:00</p>
        <button class="next-btn" id="next-btn">NEXT LEVEL</button>
    </div>
    
    <div id="permission-error">
        <p>Motion sensors required!<br><br>Please allow motion access<br>and reload the page.</p>
    </div>
    
    <div class="reveal-flash" id="reveal-flash"></div>
    <canvas id="collision-indicator"></canvas>
</div>

<script>
    // Game Configuration
    const CONFIG = {
        marbleRadius: 12,
        targetRadius: 18,
        wallThickness: 8,
        sensitivity: 0.35,
        friction: 0.96,
        maxSpeed: 8,
        collisionRevealRadius: 80,
        collisionRevealDuration: 150,
        targetPulseSpeed: 0.003,
    };
    
    // Game State
    const state = {
        level: 1,
        playing: false,
        startTime: 0,
        marble: { x: 0, y: 0, vx: 0, vy: 0 },
        target: { x: 0, y: 0 },
        walls: [],
        tilt: { x: 0, y: 0 },
        lastCollision: 0,
        won: false,
    };
    
    // DOM Elements
    const canvas = document.getElementById('game-canvas');
    const ctx = canvas.getContext('2d');
    const collisionCanvas = document.getElementById('collision-indicator');
    const collisionCtx = collisionCanvas.getContext('2d');
    const startScreen = document.getElementById('start-screen');
    const winScreen = document.getElementById('win-screen');
    const hud = document.getElementById('hud');
    const levelNum = document.getElementById('level-num');
    const timerDisplay = document.getElementById('timer');
    const winTime = document.getElementById('win-time');
    const startBtn = document.getElementById('start-btn');
    const nextBtn = document.getElementById('next-btn');
    const permissionError = document.getElementById('permission-error');
    const revealFlash = document.getElementById('reveal-flash');
    
    // Resize handling
    function resize() {
        const dpr = window.devicePixelRatio || 1;
        canvas.width = window.innerWidth * dpr;
        canvas.height = window.innerHeight * dpr;
        canvas.style.width = window.innerWidth + 'px';
        canvas.style.height = window.innerHeight + 'px';
        ctx.scale(dpr, dpr);
        
        collisionCanvas.width = window.innerWidth * dpr;
        collisionCanvas.height = window.innerHeight * dpr;
        collisionCanvas.style.width = window.innerWidth + 'px';
        collisionCanvas.style.height = window.innerHeight + 'px';
        collisionCtx.scale(dpr, dpr);
    }
    
    window.addEventListener('resize', resize);
    resize();
    
    // Maze Generation
    function generateMaze(level) {
        const w = window.innerWidth;
        const h = window.innerHeight;
        const walls = [];
        const padding = 30;
        const cellSize = Math.min(w, h) / (4 + Math.floor(level / 2));
        
        // Outer walls
        walls.push({ x1: padding, y1: padding, x2: w - padding, y2: padding });
        walls.push({ x1: w - padding, y1: padding, x2: w - padding, y2: h - padding });
        walls.push({ x1: w - padding, y1: h - padding, x2: padding, y2: h - padding });
        walls.push({ x1: padding, y1: h - padding, x2: padding, y2: padding });
        
        // Generate maze using recursive division
        const maze = generateRecursiveMaze(
            padding + cellSize,
            padding + cellSize,
            w - padding * 2 - cellSize * 2,
            h - padding * 2 - cellSize * 2,
            Math.min(3 + level, 6),
            level
        );
        
        walls.push(...maze);
        
        // Add some random obstacles based on level
        const obstacleCount = Math.min(level * 2, 12);
        for (let i = 0; i < obstacleCount; i++) {
            const length = 30 + Math.random() * 60;
            const x = padding + cellSize + Math.random() * (w - padding * 2 - cellSize * 2 - length);
            const y = padding + cellSize + Math.random() * (h - padding * 2 - cellSize * 2 - length);
            
            if (Math.random() > 0.5) {
                walls.push({ x1: x, y1: y, x2: x + length, y2: y });
            } else {
                walls.push({ x1: x, y1: y, x2: x, y2: y + length });
            }
        }
        
        return walls;
    }
    
    function generateRecursiveMaze(x, y, width, height, depth, level) {
        const walls = [];
        if (depth <= 0 || width < 60 || height < 60) return walls;
        
        const horizontal = height > width;
        
        if (horizontal) {
            const splitY = y + 40 + Math.random() * (height - 80);
            const gapStart = x + Math.random() * (width - 60);
            const gapEnd = gapStart + 50 + Math.random() * 30;
            
            if (gapStart > x) {
                walls.push({ x1: x, y1: splitY, x2: gapStart, y2: splitY });
            }
            if (gapEnd < x + width) {
                walls.push({ x1: gapEnd, y1: splitY, x2: x + width, y2: splitY });
            }
            
            walls.push(...generateRecursiveMaze(x, y, width, splitY - y, depth - 1, level));
            walls.push(...generateRecursiveMaze(x, splitY, width, height - (splitY - y), depth - 1, level));
        } else {
            const splitX = x + 40 + Math.random() * (width - 80);
            const gapStart = y + Math.random() * (height - 60);
            const gapEnd = gapStart + 50 + Math.random() * 30;
            
            if (gapStart > y) {
                walls.push({ x1: splitX, y1: y, x2: splitX, y2: gapStart });
            }
            if (gapEnd < y + height) {
                walls.push({ x1: splitX, y1: gapEnd, x2: splitX, y2: y + height });
            }
            
            walls.push(...generateRecursiveMaze(x, y, splitX - x, height, depth - 1, level));
            walls.push(...generateRecursiveMaze(splitX, y, width - (splitX - x), height, depth - 1, level));
        }
        
        return walls;
    }
    
    // Initialize level
    function initLevel(level) {
        const w = window.innerWidth;
        const h = window.innerHeight;
        const padding = 60;
        
        state.walls = generateMaze(level);
        
        // Place marble in a corner area
        state.marble = {
            x: padding + 30,
            y: padding + 30,
            vx: 0,
            vy: 0
        };
        
        // Place target in opposite area
        state.target = {
            x: w - padding - 30,
            y: h - padding - 30
        };
        
        state.won = false;
        state.startTime = Date.now();
        levelNum.textContent = level;
    }
    
    // Collision detection
    function pointToSegmentDistance(px, py, x1, y1, x2, y2) {
        const dx = x2 - x1;
        const dy = y2 - y1;
        const lengthSq = dx * dx + dy * dy;
        
        let t = 0;
        if (lengthSq > 0) {
            t = Math.max(0, Math.min(1, ((px - x1) * dx + (py - y1) * dy) / lengthSq));
        }
        
        const nearestX = x1 + t * dx;
        const nearestY = y1 + t * dy;
        
        return {
            distance: Math.sqrt((px - nearestX) ** 2 + (py - nearestY) ** 2),
            nearestX,
            nearestY,
            normalX: px - nearestX,
            normalY: py - nearestY
        };
    }
    
    function checkCollisions() {
        const { marble, walls } = state;
        let collided = false;
        let collisionPoint = null;
        
        for (const wall of walls) {
            const result = pointToSegmentDistance(
                marble.x, marble.y,
                wall.x1, wall.y1, wall.x2, wall.y2
            );
            
            const minDist = CONFIG.marbleRadius + CONFIG.wallThickness / 2;
            
            if (result.distance < minDist) {
                collided = true;
                collisionPoint = { x: result.nearestX, y: result.nearestY };
                
                // Push marble out
                const overlap = minDist - result.distance;
                const len = Math.sqrt(result.normalX ** 2 + result.normalY ** 2);
                if (len > 0) {
                    marble.x += (result.normalX / len) * overlap;
                    marble.y += (result.normalY / len) * overlap;
                    
                    // Reflect velocity
                    const nx = result.normalX / len;
                    const ny = result.normalY / len;
                    const dot = marble.vx * nx + marble.vy * ny;
                    marble.vx -= 1.5 * dot * nx;
                    marble.vy -= 1.5 * dot * ny;
                    
                    // Dampen on collision
                    marble.vx *= 0.5;
                    marble.vy *= 0.5;
                }
            }
        }
        
        if (collided && collisionPoint) {
            triggerCollisionReveal(collisionPoint);
            triggerHaptic();
        }
        
        return collided;
    }
    
    function triggerCollisionReveal(point) {
        const now = Date.now();
        if (now - state.lastCollision < 50) return;
        state.lastCollision = now;
        
        // Draw reveal on collision canvas
        collisionCtx.clearRect(0, 0, window.innerWidth, window.innerHeight);
        
        const gradient = collisionCtx.createRadialGradient(
            point.x, point.y, 0,
            point.x, point.y, CONFIG.collisionRevealRadius
        );
        gradient.addColorStop(0, 'rgba(255, 100, 100, 0.4)');
        gradient.addColorStop(0.5, 'rgba(255, 50, 50, 0.2)');
        gradient.addColorStop(1, 'transparent');
        
        collisionCtx.fillStyle = gradient;
        collisionCtx.fillRect(0, 0, window.innerWidth, window.innerHeight);
        
        // Draw nearby walls
        collisionCtx.strokeStyle = 'rgba(255, 100, 100, 0.6)';
        collisionCtx.lineWidth = CONFIG.wallThickness;
        collisionCtx.lineCap = 'round';
        
        for (const wall of state.walls) {
            const dist = Math.min(
                pointToSegmentDistance(point.x, point.y, wall.x1, wall.y1, wall.x2, wall.y2).distance,
                CONFIG.collisionRevealRadius * 1.5
            );
            
            if (dist < CONFIG.collisionRevealRadius * 1.5) {
                const alpha = 1 - (dist / (CONFIG.collisionRevealRadius * 1.5));
                collisionCtx.strokeStyle = `rgba(255, 100, 100, )`;
                collisionCtx.beginPath();
                collisionCtx.moveTo(wall.x1, wall.y1);
                collisionCtx.lineTo(wall.x2, wall.y2);
                collisionCtx.stroke();
            }
        }
        
        collisionCanvas.classList.add('active');
        
        setTimeout(() => {
            collisionCanvas.classList.remove('active');
            collisionCtx.clearRect(0, 0, window.innerWidth, window.innerHeight);
        }, CONFIG.collisionRevealDuration);
    }
    
    function triggerHaptic() {
        if (navigator.vibrate) {
            navigator.vibrate(30);
        }
    }
    
    // Check win condition
    function checkWin() {
        const { marble, target } = state;
        const dist = Math.sqrt(
            (marble.x - target.x) ** 2 + (marble.y - target.y) ** 2
        );
        
        return dist < CONFIG.marbleRadius + CONFIG.targetRadius;
    }
    
    // Physics update
    function updatePhysics() {
        if (!state.playing || state.won) return;
        
        const { marble, tilt } = state;
        
        // Apply tilt as acceleration
        marble.vx += tilt.x * CONFIG.sensitivity;
        marble.vy += tilt.y * CONFIG.sensitivity;
        
        // Apply friction
        marble.vx *= CONFIG.friction;
        marble.vy *= CONFIG.friction;
        
        // Clamp speed
        const speed = Math.sqrt(marble.vx ** 2 + marble.vy ** 2);
        if (speed > CONFIG.maxSpeed) {
            marble.vx = (marble.vx / speed) * CONFIG.maxSpeed;
            marble.vy = (marble.vy / speed) * CONFIG.maxSpeed;
        }
        
        // Update position
        marble.x += marble.vx;
        marble.y += marble.vy;
        
        // Check collisions
        checkCollisions();
        
        // Check win
        if (checkWin()) {
            state.won = true;
            showWin();
        }
    }
    
    // Render
    function render(time) {
        ctx.clearRect(0, 0, window.innerWidth, window.innerHeight);
        
        // Pure black background
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, window.innerWidth, window.innerHeight);
        
        if (!state.playing) return;
        
        const { marble, target } = state;
        
        // Draw target (pulsing glow)
        const pulse = 0.7 + 0.3 * Math.sin(time * CONFIG.targetPulseSpeed);
        const targetGradient = ctx.createRadialGradient(
            target.x, target.y, 0,
            target.x, target.y, CONFIG.targetRadius * 3 * pulse
        );
        targetGradient.addColorStop(0, 'rgba(16, 185, 129, 0.9)');
        targetGradient.addColorStop(0.3, 'rgba(16, 185, 129, 0.4)');
        targetGradient.addColorStop(0.7, 'rgba(16, 185, 129, 0.1)');
        targetGradient.addColorStop(1, 'transparent');
        
        ctx.beginPath();
        ctx.arc(target.x, target.y, CONFIG.targetRadius * 3 * pulse, 0, Math.PI * 2);
        ctx.fillStyle = targetGradient;
        ctx.fill();
        
        // Target core
        ctx.beginPath();
        ctx.arc(target.x, target.y, CONFIG.targetRadius, 0, Math.PI * 2);
        const targetCore = ctx.createRadialGradient(
            target.x - 5, target.y - 5, 0,
            target.x, target.y, CONFIG.targetRadius
        );
        targetCore.addColorStop(0, '#6ee7b7');
        targetCore.addColorStop(0.5, '#10b981');
        targetCore.addColorStop(1, '#047857');
        ctx.fillStyle = targetCore;
        ctx.fill();
        
        // Draw marble
        // Outer glow
        const marbleGlow = ctx.createRadialGradient(
            marble.x, marble.y, CONFIG.marbleRadius * 0.5,
            marble.x, marble.y, CONFIG.marbleRadius * 4
        );
        marbleGlow.addColorStop(0, 'rgba(110, 231, 255, 0.6)');
        marbleGlow.addColorStop(0.5, 'rgba(110, 231, 255, 0.2)');
        marbleGlow.addColorStop(1, 'transparent');
        
        ctx.beginPath();
        ctx.arc(marble.x, marble.y, CONFIG.marbleRadius * 4, 0, Math.PI * 2);
        ctx.fillStyle = marbleGlow;
        ctx.fill();
        
        // Marble body
        const marbleGradient = ctx.createRadialGradient(
            marble.x - CONFIG.marbleRadius * 0.3,
            marble.y - CONFIG.marbleRadius * 0.3,
            0,
            marble.x, marble.y, CONFIG.marbleRadius
        );
        marbleGradient.addColorStop(0, '#ffffff');
        marbleGradient.addColorStop(0.3, '#6ee7ff');
        marbleGradient.addColorStop(0.7, '#0ea5e9');
        marbleGradient.addColorStop(1, '#0369a1');
        
        ctx.beginPath();
        ctx.arc(marble.x, marble.y, CONFIG.marbleRadius, 0, Math.PI * 2);
        ctx.fillStyle = marbleGradient;
        ctx.fill();
        
        // Highlight
        ctx.beginPath();
        ctx.arc(
            marble.x - CONFIG.marbleRadius * 0.3,
            marble.y - CONFIG.marbleRadius * 0.3,
            CONFIG.marbleRadius * 0.3,
            0, Math.PI * 2
        );
        ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
        ctx.fill();
    }
    
    // Timer update
    function updateTimer() {
        if (!state.playing || state.won) return;
        
        const elapsed = Date.now() - state.startTime;
        const seconds = Math.floor(elapsed / 1000);
        const minutes = Math.floor(seconds / 60);
        const secs = seconds % 60;
        
        timerDisplay.textContent = 
            String(minutes).padStart(2, '0') + ':' + 
            String(secs).padStart(2, '0');
    }
    
    // Show win
    function showWin() {
        const elapsed = Date.now() - state.startTime;
        const seconds = Math.floor(elapsed / 1000);
        const minutes = Math.floor(seconds / 60);
        const secs = seconds % 60;
        
        winTime.textContent = 'TIME: ' + 
            String(minutes).padStart(2, '0') + ':' + 
            String(secs).padStart(2, '0');
        
        winScreen.classList.add('visible');
        
        // Celebration haptic
        if (navigator.vibrate) {
            navigator.vibrate([50, 50, 50, 50, 100]);
        }
    }
    
    // Motion handling
    function handleMotion(event) {
        const { accelerationIncludingGravity } = event;
        if (!accelerationIncludingGravity) return;
        
        // Get tilt values (negative because we want marble to roll "downhill")
        // Swap and adjust based on orientation
        let x = accelerationIncludingGravity.x || 0;
        let y = accelerationIncludingGravity.y || 0;
        
        // Adjust for portrait orientation (marble rolls "downhill")
        state.tilt.x = x;
        state.tilt.y = -y;
    }
    
    // Request permission for iOS (non-blocking)
    async function requestMotionPermission() {
        if (typeof DeviceMotionEvent !== 'undefined' && 
            typeof DeviceMotionEvent.requestPermission === 'function') {
            try {
                const permission = await DeviceMotionEvent.requestPermission();
                if (permission === 'granted') {
                    window.addEventListener('devicemotion', handleMotion);
                    console.log('Motion permission granted');
                    return true;
                } else {
                    console.log('Motion permission denied - using touch controls');
                    return false;
                }
            } catch (e) {
                console.log('Motion permission error - using touch controls', e);
                return false;
            }
        } else if (typeof DeviceMotionEvent !== 'undefined') {
            // Non-iOS browsers - just add listener
            window.addEventListener('devicemotion', handleMotion);
            console.log('Motion events enabled (no permission needed)');
            return true;
        } else {
            console.log('No motion support - using touch controls');
            return false;
        }
    }
    
    // Start game
    async function startGame() {
        console.log('Starting game...');
        
        // Try to get motion permission but don't block on it
        requestMotionPermission();
        
        startScreen.classList.add('hidden');
        hud.classList.add('visible');
        
        initLevel(state.level);
        state.playing = true;
        console.log('Game started!');
    }
    
    // Next level
    function nextLevel() {
        winScreen.classList.remove('visible');
        state.level++;
        initLevel(state.level);
        state.playing = true;
    }
    
    // Game loop
    function gameLoop(time) {
        updatePhysics();
        updateTimer();
        render(time);
        requestAnimationFrame(gameLoop);
    }
    
    // Touch controls fallback
    let touchStartX = 0;
    let touchStartY = 0;
    let usingTouch = false;
    
    canvas.addEventListener('touchstart', (e) => {
        if (!state.playing) return;
        e.preventDefault();
        const touch = e.touches[0];
        touchStartX = touch.clientX;
        touchStartY = touch.clientY;
        usingTouch = true;
    }, { passive: false });
    
    canvas.addEventListener('touchmove', (e) => {
        if (!state.playing || !usingTouch) return;
        e.preventDefault();
        const touch = e.touches[0];
        const deltaX = touch.clientX - touchStartX;
        const deltaY = touch.clientY - touchStartY;
        
        // Apply as tilt (scaled down)
        state.tilt.x = Math.max(-10, Math.min(10, deltaX * 0.15));
        state.tilt.y = Math.max(-10, Math.min(10, deltaY * 0.15));
    }, { passive: false });
    
    canvas.addEventListener('touchend', () => {
        state.tilt.x = 0;
        state.tilt.y = 0;
        usingTouch = false;
    });
    
    // Event listeners - using both click and touchstart for reliability
    function handleStart(e) {
        e.preventDefault();
        e.stopPropagation();
        console.log('Start button pressed');
        startGame();
    }
    
    function handleNext(e) {
        e.preventDefault();
        e.stopPropagation();
        nextLevel();
    }
    
    startBtn.addEventListener('click', handleStart);
    startBtn.addEventListener('touchstart', handleStart, { passive: false });
    
    nextBtn.addEventListener('click', handleNext);
    nextBtn.addEventListener('touchstart', handleNext, { passive: false });
    
    // Prevent scrolling on body but allow buttons to work
    document.body.addEventListener('touchmove', (e) => {
        if (e.target === canvas) {
            e.preventDefault();
        }
    }, { passive: false });
    
    // Keyboard fallback for testing (arrow keys)
    document.addEventListener('keydown', (e) => {
        const force = 5;
        switch(e.key) {
            case 'ArrowLeft': state.tilt.x = -force; break;
            case 'ArrowRight': state.tilt.x = force; break;
            case 'ArrowUp': state.tilt.y = -force; break;
            case 'ArrowDown': state.tilt.y = force; break;
        }
    });
    
    document.addEventListener('keyup', (e) => {
        if (['ArrowLeft', 'ArrowRight'].includes(e.key)) state.tilt.x = 0;
        if (['ArrowUp', 'ArrowDown'].includes(e.key)) state.tilt.y = 0;
    });
    
    // Log for debugging
    console.log('VOID MARBLE loaded. Tap BEGIN to start.');
    
    // Start game loop
    requestAnimationFrame(gameLoop);
</script>
```

</body>
</html>