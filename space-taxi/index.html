<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Space Taxi - 16-Bit SNES Edition</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        :root {
            --snes-blue: #3e3ab3;
            --snes-light-blue: #5c59d4;
            --snes-gray: #c0c0c0;
            --snes-dark-gray: #404040;
            --snes-purple: #7a5ba0;
        }

        body {
            background-color: #1a1a1a;
            margin: 0;
            overflow: hidden;
            font-family: 'Press Start 2P', cursive;
            image-rendering: pixelated;
        }

        #game-container {
            position: relative;
            box-shadow: 0 0 50px rgba(0,0,0,0.8);
            border: 8px solid var(--snes-dark-gray);
            border-radius: 4px;
        }

        /* CRT Scanline Effect */
        #game-container::after {
            content: " ";
            display: block;
            position: absolute;
            top: 0; left: 0; bottom: 0; right: 0;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.15) 50%), 
                        linear-gradient(90deg, rgba(255, 0, 0, 0.03), rgba(0, 255, 0, 0.01), rgba(0, 0, 255, 0.03));
            z-index: 15;
            background-size: 100% 4px, 6px 100%;
            pointer-events: none;
        }

        canvas {
            image-rendering: pixelated;
            display: block;
            margin: 0 auto;
            background: #0b0a1a;
            touch-action: none;
        }

        .ui-panel {
            background: linear-gradient(to bottom, var(--snes-light-blue), var(--snes-blue));
            color: #fff;
            border: 4px solid #fff;
            box-shadow: inset -4px -4px 0px #000, inset 4px 4px 0px #8080ff;
            text-transform: uppercase;
        }

        .minimap {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 120px;
            height: 90px;
            background: #000;
            border: 3px solid var(--snes-gray);
            pointer-events: none;
            overflow: hidden;
            z-index: 12;
        }

        @keyframes pulse-mini {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.5); opacity: 0.7; }
        }
        .target-dot {
            animation: pulse-mini 0.8s infinite;
        }

        .speed-safe { color: #55ff55; text-shadow: 2px 2px #004400; }
        .speed-danger { color: #ff5555; text-shadow: 2px 2px #440000; }
        
        #overlay h1 {
            text-shadow: 4px 4px #000, -2px -2px #888;
            letter-spacing: 2px;
        }
    </style>
</head>
<body class="flex flex-col items-center justify-center min-h-screen">

    <div id="game-container" class="relative overflow-hidden">
        <!-- UI Overlay -->
        <div id="ui" class="absolute top-0 left-0 w-full p-4 flex justify-between ui-panel text-[8px] md:text-[10px] z-20 select-none pointer-events-none">
            <div class="flex gap-4">
                <div>
                    CASH $<span id="cash">0</span><br>
                    PASS <span id="pass-count">0/3</span>
                </div>
                <div>
                    FUEL <span id="fuel-val">100</span>%
                    <div class="w-20 h-3 bg-black mt-1 border border-white">
                        <div id="fuel-bar" class="h-full bg-green-500" style="width: 100%"></div>
                    </div>
                </div>
            </div>
            <div class="text-center flex flex-col items-center flex-1 px-2">
                <span id="message" class="text-yellow-300 font-bold mb-1">BEREIT</span>
                <span id="passenger-comment" class="text-white text-[7px] lowercase italic opacity-0"></span>
            </div>
            <div class="text-right">
                LV <span id="level-idx">1</span><br>
                SPD <span id="speed-val" class="speed-safe">0.0</span><br>
                TO <span id="target" class="text-white">-</span>
            </div>
        </div>

        <!-- Start/Game Over Screens -->
        <div id="overlay" class="absolute inset-0 flex flex-col items-center justify-center bg-black/90 z-30 text-white text-center p-6">
            <h1 class="text-2xl md:text-5xl font-bold mb-6 text-yellow-500 italic uppercase">Space Taxi</h1>
            <div class="bg-blue-900 border-4 border-white p-4 mb-8 max-w-md shadow-[8px_8px_0px_#000]">
                <p id="overlay-msg" class="text-[8px] md:text-[12px] leading-loose">
                    WILLKOMMEN PILOT!<br><br>
                    - TRANSPORTIERE 3 GÄSTE<br>
                    - TANKEN AN GRÜNEN ZONEN<br>
                    - LANDEN BEI <span class="text-green-400">GRÜNEM TACHO</span>
                </p>
            </div>
            <button id="start-btn" class="px-8 py-4 bg-purple-600 hover:bg-purple-500 text-white font-bold border-4 border-white shadow-[6px_6px_0px_#000] active:translate-y-1 active:shadow-none uppercase text-xs md:text-sm">Starten</button>
        </div>

        <canvas id="gameCanvas" class="retro-border"></canvas>

        <!-- Minimap -->
        <div class="minimap" id="minimap"></div>

        <!-- Touch Controls -->
        <div id="controls" class="absolute bottom-4 left-4 right-4 flex justify-between md:hidden z-20 pointer-events-none">
            <div class="flex gap-4 pointer-events-auto">
                <button id="btn-left" class="w-14 h-14 bg-gray-400/50 rounded border-4 border-white flex items-center justify-center text-xl">←</button>
                <button id="btn-right" class="w-14 h-14 bg-gray-400/50 rounded border-4 border-white flex items-center justify-center text-xl">→</button>
            </div>
            <div class="pointer-events-auto">
                <button id="btn-up" class="w-16 h-16 bg-purple-500/50 rounded-full border-4 border-white flex items-center justify-center text-2xl">↑</button>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const startBtn = document.getElementById('start-btn');
        const overlay = document.getElementById('overlay');
        const overlayMsg = document.getElementById('overlay-msg');
        
        let gameState = 'START';
        let cash = 0;
        let fuel = 100;
        let currentLevelIdx = 0;
        let animationId;
        let passengerIndex = 0; 
        let particles = [];
        let fuelAlertTriggered = false;
        
        const VIEW_W = 800;
        const VIEW_H = 600;
        const TAXI_WIDTH = 34;
        const TAXI_HEIGHT = 22;
        const MAX_LANDING_VEL = 0.8;

        const camera = { x: 0, y: 0 };
        const taxi = {
            x: 100, y: 100, vx: 0, vy: 0, angle: 0,
            thrusting: { up: false, left: false, right: false },
            landedOn: null,
            reset(x = 100, y = 100) {
                this.x = x; this.y = y; this.vx = 0; this.vy = 0; this.angle = 0;
                this.landedOn = null;
                particles = [];
                fuelAlertTriggered = false;
            }
        };

        const boardingComments = [
            "endlich!", "wackelig hier...", "beeilung!",
            "sicher?", "riecht komisch...", "pass bloß auf!"
        ];

        const landingComments = [
            "kein trinkgeld.", "bruchlandung...", "endlich raus.",
            "such dir 'nen job.", "ganz okay...", "schwache leistung."
        ];

        class MovingObstacle {
            constructor(x, y, w, h, xRange, yRange, speed) {
                this.startX = x; this.startY = y;
                this.x = x; this.y = y;
                this.w = w; this.h = h;
                this.xRange = xRange; this.yRange = yRange;
                this.speed = speed;
                this.time = Math.random() * 100;
            }
            update() {
                this.time += this.speed;
                if (this.xRange > 0) this.x = this.startX + Math.sin(this.time) * (this.xRange / 2);
                if (this.yRange > 0) this.y = this.startY + Math.cos(this.time) * (this.yRange / 2);
            }
            draw(ctx, cam) {
                ctx.fillStyle = '#ff3333';
                // Beveled look for obstacle
                ctx.fillRect(this.x - cam.x, this.y - cam.y, this.w, this.h);
                ctx.fillStyle = '#ff8888';
                ctx.fillRect(this.x - cam.x, this.y - cam.y, this.w, 4);
                ctx.fillRect(this.x - cam.x, this.y - cam.y, 4, this.h);
                ctx.fillStyle = '#880000';
                ctx.fillRect(this.x - cam.x + this.w - 4, this.y - cam.y, 4, this.h);
                ctx.fillRect(this.x - cam.x, this.y - cam.y + this.h - 4, this.w, 4);
            }
        }

        const levels = [
            {
                worldW: 1800, worldH: 1400,
                spawn: { x: 100, y: 100 },
                platforms: [
                    { x: 50, y: 300, w: 110, h: 20, id: 1 },
                    { x: 1500, y: 300, w: 120, h: 20, id: 2 },
                    { x: 800, y: 800, w: 110, h: 20, id: 3 },
                    { x: 100, y: 1200, w: 110, h: 20, id: 4 },
                    { x: 1600, y: 1300, w: 110, h: 20, id: 5 },
                    { x: 900, y: 250, w: 110, h: 20, id: 99, isFuelStation: true },
                    { x: 1300, y: 1200, w: 110, h: 20, id: 98, isFuelStation: true }
                ],
                walls: [
                    { x: 0, y: 0, w: 1800, h: 40 }, { x: 0, y: 1360, w: 1800, h: 40 },
                    { x: 0, y: 0, w: 40, h: 1400 }, { x: 1760, y: 0, w: 40, h: 1400 },
                    { x: 400, y: 400, w: 60, h: 600 }, { x: 1200, y: 400, w: 60, h: 600 }
                ],
                obstacles: [
                    new MovingObstacle(600, 300, 48, 48, 400, 0, 0.02),
                    new MovingObstacle(1000, 1000, 64, 32, 0, 400, 0.03),
                    new MovingObstacle(1400, 600, 48, 48, 200, 200, 0.02)
                ],
                passengers: [
                    { from: 1, to: 2 }, { from: 4, to: 3 }, { from: 5, to: 1 }
                ]
            },
            {
                worldW: 2400, worldH: 1800,
                spawn: { x: 100, y: 100 },
                platforms: [
                    { x: 100, y: 350, w: 110, h: 20, id: 1 },
                    { x: 2100, y: 200, w: 110, h: 20, id: 2 },
                    { x: 1100, y: 900, w: 160, h: 20, id: 3 },
                    { x: 100, y: 1600, w: 110, h: 20, id: 4 },
                    { x: 2100, y: 1600, w: 110, h: 20, id: 5 },
                    { x: 1150, y: 250, w: 90, h: 20, id: 99, isFuelStation: true },
                    { x: 1200, y: 1400, w: 90, h: 20, id: 98, isFuelStation: true }
                ],
                walls: [
                    { x: 0, y: 0, w: 2400, h: 40 }, { x: 0, y: 1760, w: 2400, h: 40 },
                    { x: 0, y: 0, w: 40, h: 1800 }, { x: 2360, y: 0, w: 40, h: 1800 },
                    { x: 500, y: 0, w: 60, h: 600 }, { x: 500, y: 1000, w: 60, h: 800 },
                    { x: 1800, y: 0, w: 60, h: 800 }, { x: 1800, y: 1200, w: 60, h: 600 },
                    { x: 900, y: 600, w: 600, h: 40 }
                ],
                obstacles: [
                    new MovingObstacle(300, 800, 110, 32, 200, 0, 0.05),
                    new MovingObstacle(2000, 800, 110, 32, 200, 0, 0.05),
                    new MovingObstacle(1150, 400, 48, 48, 600, 0, 0.02),
                    new MovingObstacle(1150, 1400, 48, 48, 600, 0, 0.03),
                    new MovingObstacle(100, 1000, 32, 32, 2000, 0, 0.01)
                ],
                passengers: [
                    { from: 2, to: 4 }, { from: 1, to: 5 }, { from: 3, to: 2 }
                ]
            }
        ];

        let activePassenger = null;
        let audioCtx = null;
        let noiseBuffer = null;
        let engineGainNode = null;
        let engineFilterNode = null;
        let noiseSource = null;
        let bgmInterval = null;
        let bgmBeat = 0;

        function setupEngineAudio() {
            if (!audioCtx) return;
            const bufferSize = audioCtx.sampleRate * 2;
            noiseBuffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const output = noiseBuffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) {
                output[i] = Math.random() * 2 - 1;
            }

            noiseSource = audioCtx.createBufferSource();
            noiseSource.buffer = noiseBuffer;
            noiseSource.loop = true;

            engineFilterNode = audioCtx.createBiquadFilter();
            engineFilterNode.type = 'lowpass';
            engineFilterNode.frequency.setValueAtTime(120, audioCtx.currentTime);
            engineFilterNode.Q.setValueAtTime(10, audioCtx.currentTime); 

            engineGainNode = audioCtx.createGain();
            engineGainNode.gain.setValueAtTime(0, audioCtx.currentTime);

            noiseSource.connect(engineFilterNode);
            engineFilterNode.connect(engineGainNode);
            engineGainNode.connect(audioCtx.destination);
            noiseSource.start();
        }

        function updateEngineAudio(isThrusting) {
            if (!engineGainNode) return;
            const targetGain = isThrusting ? 0.4 : 0; 
            const targetFreq = isThrusting ? 380 : 120; 
            
            engineGainNode.gain.setTargetAtTime(targetGain, audioCtx.currentTime, 0.05);
            engineFilterNode.frequency.setTargetAtTime(targetFreq, audioCtx.currentTime, 0.1);
        }

        function startBGM() {
            if (bgmInterval) return;
            
            // Bass: Deep Triangle pulses
            const bassline = [130.81, 130.81, 110.00, 110.00, 98.00, 98.00, 130.81, 146.83];
            // Arpeggio: Faster pulsing synth
            const arpeggio = [261.63, 329.63, 392.00, 523.25, 392.00, 329.63];
            // Melody: Slow, atmospheric Lead
            const melody = [
                523.25, 0, 587.33, 0, 659.25, 0, 523.25, 0,
                783.99, 0, 698.46, 0, 659.25, 0, 587.33, 0
            ];

            bgmInterval = setInterval(() => {
                if (gameState !== 'PLAYING') return;

                // 1. Bass (Every 2 beats)
                if (bgmBeat % 2 === 0) {
                    playSound(bassline[(bgmBeat / 2) % bassline.length], 0.4, 'triangle', 0.04);
                }

                // 2. Arpeggio (Fast)
                playSound(arpeggio[bgmBeat % arpeggio.length], 0.15, 'sine', 0.015);

                // 3. Lead Melody (Slow)
                const melNote = melody[(Math.floor(bgmBeat / 2)) % melody.length];
                if (melNote > 0 && bgmBeat % 4 === 0) {
                    playSound(melNote, 0.8, 'square', 0.015, melNote * 0.98);
                }

                // 4. Subtle Percussion (Noise bursts)
                if (bgmBeat % 8 === 4) {
                    playPercussion(0.015); // Snare-ish
                } else if (bgmBeat % 2 === 0) {
                    playPercussion(0.005, 1500); // Hi-hat-ish
                }

                bgmBeat++;
            }, 180); // Higher BPM for the 180ms interval
        }

        function playPercussion(volume, filterFreq = 1000) {
            if (!audioCtx || !noiseBuffer) return;
            const source = audioCtx.createBufferSource();
            const filter = audioCtx.createBiquadFilter();
            const gain = audioCtx.createGain();

            source.buffer = noiseBuffer;
            filter.type = 'highpass';
            filter.frequency.setValueAtTime(filterFreq, audioCtx.currentTime);
            
            gain.gain.setValueAtTime(volume, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + 0.1);

            source.connect(filter);
            filter.connect(gain);
            gain.connect(audioCtx.destination);
            source.start();
        }

        function playSound(freq, duration, type = 'square', volume = 0.1, slideTo = null) {
            if (!audioCtx) return;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = type;
            osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
            if (slideTo !== null) osc.frequency.exponentialRampToValueAtTime(slideTo, audioCtx.currentTime + duration);
            gain.gain.setValueAtTime(volume, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + duration);
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.start();
            osc.stop(audioCtx.currentTime + duration);
        }

        function createParticle(x, y, color, side) {
            particles.push({
                x, y,
                vx: (Math.random() - 0.5) * 5,
                vy: side === 'up' ? Math.random() * 5 + 3 : (Math.random() - 0.5) * 4,
                life: 1.0,
                decay: 0.03 + Math.random() * 0.05,
                color
            });
        }

        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.life -= p.decay;
                if (p.life <= 0) particles.splice(i, 1);
            }
        }

        function showPassengerComment(type) {
            const list = type === 'boarding' ? boardingComments : landingComments;
            const comment = list[Math.floor(Math.random() * list.length)];
            const el = document.getElementById('passenger-comment');
            el.innerText = `[ ${comment} ]`;
            el.style.opacity = "1";
            setTimeout(() => { el.style.opacity = "0"; }, 2500);
        }

        function initPassenger() {
            const level = levels[currentLevelIdx];
            const passData = level.passengers[passengerIndex];
            const pStart = level.platforms.find(pl => pl.id === passData.from);
            activePassenger = {
                state: 'WAITING',
                fromId: passData.from,
                toId: passData.to,
                x: pStart.x + pStart.w / 2,
                y: pStart.y - 5
            };
            document.getElementById('pass-count').innerText = `${passengerIndex + 1}/3`;
            document.getElementById('target').innerText = "P" + activePassenger.fromId;
            document.getElementById('target').style.color = "#ffff55";
            document.getElementById('message').innerText = "GAST HOLEN";
        }

        function resize() {
            canvas.width = VIEW_W;
            canvas.height = VIEW_H;
            const screenW = Math.min(window.innerWidth - 20, VIEW_W);
            canvas.style.width = screenW + 'px';
            canvas.style.height = (screenW * 0.75) + 'px';
        }
        window.addEventListener('resize', resize);
        resize();

        const keys = {};
        window.addEventListener('keydown', e => keys[e.code] = true);
        window.addEventListener('keyup', e => keys[e.code] = false);

        const btns = { up: document.getElementById('btn-up'), left: document.getElementById('btn-left'), right: document.getElementById('btn-right') };
        Object.keys(btns).forEach(k => {
            btns[k].addEventListener('touchstart', (e) => { e.preventDefault(); btns[k].isDown = true; });
            btns[k].addEventListener('touchend', (e) => { e.preventDefault(); btns[k].isDown = false; });
        });

        function checkCollision(obj, target) {
            return obj.x - TAXI_WIDTH / 2 < target.x + target.w &&
                   obj.x + TAXI_WIDTH / 2 > target.x &&
                   obj.y - TAXI_HEIGHT / 2 < target.y + target.h &&
                   obj.y + TAXI_HEIGHT / 2 > target.y;
        }

        function gameLoop() {
            if (gameState !== 'PLAYING') return;
            const level = levels[currentLevelIdx];

            const thrustUp = keys['ArrowUp'] || keys['KeyW'] || btns.up.isDown;
            const thrustLeft = keys['ArrowLeft'] || keys['KeyA'] || btns.left.isDown;
            const thrustRight = keys['ArrowRight'] || keys['KeyD'] || btns.right.isDown;
            const isAnyThrusting = (thrustUp || thrustLeft || thrustRight) && fuel > 0;

            updateEngineAudio(isAnyThrusting);

            if (fuel > 0) {
                if (thrustUp) {
                    taxi.vy -= 0.12; fuel -= 0.16;
                    createParticle(taxi.x, taxi.y + 10, '#ffff55', 'up');
                    createParticle(taxi.x, taxi.y + 10, '#ff5500', 'up');
                }
                if (thrustLeft) { 
                    taxi.vx -= 0.09; fuel -= 0.06; taxi.angle = -0.15; 
                    createParticle(taxi.x + 14, taxi.y, '#00ffff', 'side');
                }
                else if (thrustRight) { 
                    taxi.vx += 0.09; fuel -= 0.06; taxi.angle = 0.15; 
                    createParticle(taxi.x - 14, taxi.y, '#00ffff', 'side');
                } else taxi.angle *= 0.88;
            } else {
                taxi.angle *= 0.9;
                if (!fuelAlertTriggered) {
                    fuelAlertTriggered = true;
                    playSound(350, 1.8, 'sine', 0.4, 5);
                    document.getElementById('message').innerText = "MOTOR AUS!";
                }
            }

            taxi.vy += 0.038; taxi.vx *= 0.982; taxi.vy *= 0.982;
            taxi.x += taxi.vx; taxi.y += taxi.vy;

            const speed = Math.sqrt(taxi.vx * taxi.vx + taxi.vy * taxi.vy);
            updateParticles();
            if (fuel <= 0) fuel = 0;

            camera.x = Math.max(0, Math.min(taxi.x - VIEW_W / 2, level.worldW - VIEW_W));
            camera.y = Math.max(0, Math.min(taxi.y - VIEW_H / 2, level.worldH - VIEW_H));

            for (let wall of level.walls) if (checkCollision(taxi, wall)) { crash(); return; }
            for (let obs of level.obstacles) {
                obs.update();
                if (checkCollision(taxi, obs)) { crash(); return; }
            }

            let landing = false;
            let currentPlat = null;
            for (let plat of level.platforms) {
                if (checkCollision(taxi, plat)) {
                    if (speed > MAX_LANDING_VEL || Math.abs(taxi.angle) > 0.22) { crash(); return; }
                    else {
                        taxi.y = plat.y - TAXI_HEIGHT / 2;
                        taxi.vy = 0; taxi.vx = 0; taxi.angle = 0;
                        landing = true; taxi.landedOn = plat.id;
                        currentPlat = plat;
                    }
                }
            }
            if (!landing) taxi.landedOn = null;

            if (currentPlat && currentPlat.isFuelStation && fuel < 100) {
                fuel = Math.min(100, fuel + 0.45);
                if (cash > 0) cash = Math.max(0, cash - 0.12);
                document.getElementById('message').innerText = "TANKE...";
                if (Math.random() > 0.82) playSound(1300, 0.06, 'triangle', 0.04);
            }

            if (activePassenger.state === 'WAITING' && taxi.landedOn === activePassenger.fromId) {
                activePassenger.state = 'IN_TAXI';
                playSound(550, 0.22, 'sine');
                document.getElementById('target').innerText = "P" + activePassenger.toId;
                document.getElementById('message').innerText = "LOS JETZT!";
                showPassengerComment('boarding');
            } else if (activePassenger.state === 'IN_TAXI' && taxi.landedOn === activePassenger.toId) {
                activePassenger.state = 'ARRIVED';
                cash += 100;
                playSound(750, 0.35, 'sine');
                showPassengerComment('landing');
                passengerIndex++;
                if (passengerIndex < 3) initPassenger();
                else {
                    document.getElementById('message').innerText = "SEKTOR KLAR!";
                    setTimeout(nextLevel, 1500);
                }
            }

            updateUI(speed);
            updateMinimap();
            draw();
            animationId = requestAnimationFrame(gameLoop);
        }

        function updateUI(speed) {
            document.getElementById('cash').innerText = Math.floor(cash);
            document.getElementById('fuel-val').innerText = Math.floor(fuel);
            const fuelBar = document.getElementById('fuel-bar');
            fuelBar.style.width = fuel + '%';
            fuelBar.className = fuel < 25 ? 'h-full bg-red-600' : (fuel < 50 ? 'h-full bg-orange-500' : 'h-full bg-green-500');
            const speedEl = document.getElementById('speed-val');
            speedEl.innerText = speed.toFixed(1);
            speedEl.className = speed <= MAX_LANDING_VEL ? 'speed-safe' : 'speed-danger';
        }

        function updateMinimap() {
            const m = document.getElementById('minimap');
            const level = levels[currentLevelIdx];
            const MAP_W = 120, MAP_H = 90;
            const tx = (taxi.x / level.worldW) * MAP_W, ty = (taxi.y / level.worldH) * MAP_H;

            let markers = `<div style="position:absolute; left:${tx-2}px; top:${ty-2}px; width:4px; height:4px; background:yellow; z-index:10;"></div>`;
            level.platforms.filter(p => p.isFuelStation).forEach(f => {
                const fx = (f.x / level.worldW) * MAP_W, fy = (f.y / level.worldH) * MAP_H;
                markers += `<div style="position:absolute; left:${fx}px; top:${fy}px; width:8px; height:3px; background:#00ff00; z-index:5;"></div>`;
            });
            if (activePassenger) {
                const goalId = activePassenger.state === 'WAITING' ? activePassenger.fromId : activePassenger.toId;
                const goalPlat = level.platforms.find(p => p.id === goalId);
                if (goalPlat) {
                    const gx = (goalPlat.x / level.worldW) * MAP_W, gy = (goalPlat.y / level.worldH) * MAP_H;
                    markers += `<div class="target-dot" style="position:absolute; left:${gx-1}px; top:${gy-2}px; width:10px; height:4px; background:#ff00ff; border:1px solid white; z-index:8;"></div>`;
                }
            }
            m.innerHTML = markers;
        }

        function draw() {
            ctx.clearRect(0, 0, VIEW_W, VIEW_H);
            const level = levels[currentLevelIdx];

            // Background Stars with parallax-ish depth
            ctx.fillStyle = '#222244';
            for(let i=0; i<60; i++) {
                let sx = (i * 145) % level.worldW - camera.x;
                let sy = (i * 210) % level.worldH - camera.y;
                if (sx >= -10 && sx <= VIEW_W + 10 && sy >= -10 && sy <= VIEW_H + 10) {
                    ctx.fillRect(sx, sy, 3, 3);
                }
            }

            // Draw Walls - Brick style
            level.walls.forEach(w => {
                const rx = w.x - camera.x, ry = w.y - camera.y;
                if (rx + w.w > 0 && rx < VIEW_W && ry + w.h > 0 && ry < VIEW_H) {
                    ctx.fillStyle = '#4a4a58';
                    ctx.fillRect(rx, ry, w.w, w.h);
                    ctx.strokeStyle = '#222';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(rx, ry, w.w, w.h);
                    // Detail lines
                    ctx.fillStyle = '#5c5c6d';
                    for(let x=0; x<w.w; x+=30) ctx.fillRect(rx+x, ry, 2, w.h);
                    for(let y=0; y<w.h; y+=20) ctx.fillRect(rx, ry+y, w.w, 2);
                }
            });

            // Draw Platforms - SNES shaded metal
            level.platforms.forEach(p => {
                const rx = p.x - camera.x, ry = p.y - camera.y;
                if (rx + p.w > 0 && rx < VIEW_W && ry + p.h > 0 && ry < VIEW_H) {
                    const colBase = p.isFuelStation ? '#2d5a27' : '#555566';
                    const colLight = p.isFuelStation ? '#44cc44' : '#888899';
                    ctx.fillStyle = colBase;
                    ctx.fillRect(rx, ry, p.w, p.h);
                    ctx.fillStyle = colLight;
                    ctx.fillRect(rx, ry, p.w, 4);
                    ctx.fillStyle = '#000';
                    ctx.fillRect(rx, ry+p.h-4, p.w, 4);
                    ctx.fillStyle = '#fff';
                    ctx.font = '8px "Press Start 2P"';
                    ctx.fillText(p.isFuelStation ? 'FUEL' : 'P'+p.id, rx + 10, ry + 14);
                }
            });

            level.obstacles.forEach(o => o.draw(ctx, camera));

            // Particles
            particles.forEach(p => {
                ctx.globalAlpha = p.life;
                ctx.fillStyle = p.color;
                ctx.fillRect(p.x - camera.x, p.y - camera.y, 4, 4);
            });
            ctx.globalAlpha = 1.0;

            // Draw Passenger - Pixel sprite
            if (activePassenger && activePassenger.state === 'WAITING') {
                const rx = activePassenger.x - camera.x, ry = activePassenger.y - camera.y;
                if (rx > 0 && rx < VIEW_W && ry > 0 && ry < VIEW_H) {
                    ctx.fillStyle = '#ff00ff'; // Body
                    ctx.fillRect(rx - 5, ry - 14, 10, 14);
                    ctx.fillStyle = '#ffccaa'; // Face
                    ctx.fillRect(rx - 3, ry - 18, 6, 6);
                    ctx.fillStyle = '#000'; // Eyes
                    ctx.fillRect(rx - 2, ry - 16, 1, 1);
                    ctx.fillRect(rx + 1, ry - 16, 1, 1);
                }
            }

            // Draw Taxi - Sprite style
            ctx.save();
            ctx.translate(taxi.x - camera.x, taxi.y - camera.y);
            ctx.rotate(taxi.angle);
            // Main body shaded
            ctx.fillStyle = fuel > 0 ? '#ccaa00' : '#444';
            ctx.fillRect(-TAXI_WIDTH/2, -TAXI_HEIGHT/2, TAXI_WIDTH, TAXI_HEIGHT-6);
            ctx.fillStyle = fuel > 0 ? '#ffff55' : '#666';
            ctx.fillRect(-TAXI_WIDTH/2, -TAXI_HEIGHT/2, TAXI_WIDTH, 5);
            ctx.fillStyle = fuel > 0 ? '#886600' : '#222';
            ctx.fillRect(-TAXI_WIDTH/2, TAXI_HEIGHT/2-10, TAXI_WIDTH, 4);
            // Glass
            ctx.fillStyle = '#00ccff';
            ctx.fillRect(4, -7, 10, 7);
            ctx.fillStyle = '#ffffff'; // Shine
            ctx.fillRect(10, -6, 2, 2);
            // Landing gear
            ctx.fillStyle = '#222';
            ctx.fillRect(-14, 5, 8, 6);
            ctx.fillRect(6, 5, 8, 6);
            ctx.restore();
        }

        function crash() {
            gameState = 'CRASHED';
            updateEngineAudio(false);
            playSound(100, 0.6, 'sawtooth', 0.5);
            playSound(30, 1.4, 'square', 0.4);
            overlay.classList.remove('hidden');
            const crashMsg = fuel <= 0 ? "TANK LEER!" : "BRUCH!";
            overlayMsg.innerHTML = `<span class="text-red-500 text-xl md:text-3xl font-bold">${crashMsg}</span><br><br>GELD VERLOREN.<br>PILOT GESCHEITERT.`;
            startBtn.innerText = "Try Again";
            cancelAnimationFrame(animationId);
        }

        function nextLevel() {
            currentLevelIdx++;
            if (currentLevelIdx >= levels.length) {
                gameState = 'SUCCESS';
                updateEngineAudio(false);
                overlay.classList.remove('hidden');
                overlayMsg.innerHTML = `<span class="text-green-500 text-xl md:text-3xl font-bold">LEGENDÄR!</span><br><br>DU HAST DEN SEKTOR EROBERT.<br>KONTO: $${Math.floor(cash)}`;
                startBtn.innerText = "New Game";
                currentLevelIdx = 0;
            } else {
                passengerIndex = 0;
                initLevel();
            }
        }

        function initLevel() {
            const level = levels[currentLevelIdx];
            taxi.reset(level.spawn.x, level.spawn.y);
            fuel = 100;
            passengerIndex = 0;
            initPassenger();
            document.getElementById('level-idx').innerText = currentLevelIdx + 1;
        }

        startBtn.onclick = () => {
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                setupEngineAudio();
                startBGM();
            }
            overlay.classList.add('hidden');
            if (gameState === 'SUCCESS' || (gameState === 'CRASHED' && passengerIndex === 0 && currentLevelIdx === 0)) cash = 0;
            gameState = 'PLAYING';
            initLevel();
            gameLoop();
        };

        draw();
    </script>
</body>
</html>